import json
import time
import math
import threading
from enum import Enum

import pyglet
import pyglet.gl as gl

from fineserver import FineServer
from finedetector import FineDetector

class FineState(Enum):
    """
    Represents the different states of the fine process.

    Attributes:
        SHOWING_RESULT (int): The state when the result is being shown.
        DETECTING_POSES (int): The state when poses are being detected.
        GENERATING_IMAGE (int): The state when an image is being generated.
    """
    SHOWING_RESULT = 0
    DETECTING_POSES = 1
    GENERATING_IMAGE = 2


class ThisIsFineWindow(pyglet.window.Window):
    """
    Represents the main window for the "This is Fine!" application.

    Attributes:
        view (pyglet.math.Mat4): The quad warp matrix loaded from warp.json.
        _generated_image_lock (threading.Lock): A lock for accessing the generated image.
        _generated_image (pyglet.image.AbstractImage): The generated image.
        _pose_image (pyglet.image.AbstractImage): The pose image.
        _frozen_pose_image (pyglet.image.AbstractImage): The frozen pose image.
        _frozen_pose_png_data (bytes): The frozen pose image data in PNG format.
        _frozen_canny_png_data (bytes): The frozen canny image data in PNG format.
        _flash_batch (pyglet.graphics.Batch): The batch for drawing the flash effect.
        _flash_rect (pyglet.shapes.Rectangle): The rectangle shape for the flash effect.
        _countdown_batch (pyglet.graphics.Batch): The batch for drawing the countdown arc.
        _countdown_arc (pyglet.shapes.Sector): The sector shape for the countdown arc.
        _wait_batch (pyglet.graphics.Batch): The batch for drawing the wait circles.
        _wait_circles (List[pyglet.shapes.Circle]): The list of wait circles.
        _pose_detector (FineDetector): The pose detector instance.
        _server (FineServer): The server instance.
        _state (FineState): The current state of the application.
        _state_start (float): The start time of the current state.

    Methods:
        cleanup(): Cleans up the resources used by the application.
        set_state(state: FineState): Sets the state of the application.
        on_close(): Event handler for the window close event.
        on_draw(): Event handler for the window draw event.
        on_key_press(symbol: pyglet.window.key, modifiers: pyglet.window.key): Event handler for the key press event.
        get_pose_image() -> pyglet.image.ImageData: Returns the pose image as an ImageData object.
        invoke_generation(): Invokes the image generation process.
        get_frozen_pose_image_png() -> bytes: Returns the frozen pose image data in PNG format.
        get_frozen_canny_image_png() -> bytes: Returns the frozen canny image data in PNG format.
        set_invoked_image(data: bytes): Sets the generated image using the provided data.
    """
    def __init__(self) -> None:
        super().__init__(
            caption="This is Fine!", width=1920, height=1080, fullscreen=True
        )
        self.set_mouse_visible(False)

        # load quad warp matrix from warp.json generated by warpcalibration.py
        with open("resources/warp.json", "r") as f:
            data = json.load(f)
            self.view = pyglet.math.Mat4(data["matrix"])

        self._generated_image_lock = threading.Lock()
        self._generated_image = pyglet.image.create(960, 540)
        self._pose_image = pyglet.image.create(960, 540)
        self._frozen_pose_image = pyglet.image.create(960, 540)
        self._frozen_pose_png_data: Optional[bytes] = None
        self._frozen_canny_png_data: Optional[bytes] = None

        self._flash_batch = pyglet.graphics.Batch()
        self._flash_rect = pyglet.shapes.Rectangle(
            0, 0, self.width, self.height, batch=self._flash_batch
        )

        self._countdown_batch = pyglet.graphics.Batch()
        self._countdown_arc = pyglet.shapes.Sector(
            int(self.width / 2),
            int(self.height / 2),
            int(self.height / 4),
            angle=0,
            start_angle=math.pi / 2,
            batch=self._countdown_batch,
        )

        self._wait_batch = pyglet.graphics.Batch()
        self._wait_circles = [
            pyglet.shapes.Circle(
                int(self.width / 2 + c * self.width / 8),
                int(self.height / 2),
                int(self.height / 16),
                batch=self._wait_batch,
            )
            for c in range(-1, 2)
        ]

        self._pose_detector = FineDetector()
        self._server = FineServer()
        self._server.pose_callback = self.get_frozen_pose_image_png
        self._server.canny_callback = self.get_frozen_canny_image_png
        self._server.invoked_callback = self.set_invoked_image

        self._state = FineState.SHOWING_RESULT
        self._state_start = time.time()

    def cleanup(self) -> None:
        """
        Cleans up the resources used by the application.
        """
        self._server.request_stop()
        self._pose_detector.request_stop()

    def set_state(self, state: FineState) -> None:
        """
        Sets the state of the application.

        Args:
            state (FineState): The state to set.
        """
        self._state = state
        self._state_start = time.time()

    def on_close(self) -> None:
        """
        Event handler for the window close event.
        """
        self.cleanup()
        super().on_close()

    def on_draw(self) -> None:
        """
        Event handler for the window draw event.
        """
        self.clear()

        time_passed = time.time() - self._state_start

        match self._state:
            case FineState.SHOWING_RESULT:
                with self._generated_image_lock:
                    self._generated_image.blit(
                        0, 0, width=self.width, height=self.height
                    )

                if time_passed >= 10:
                    self.set_state(FineState.DETECTING_POSES)
                elif time_passed > 8:
                    self._pose_image = self.get_pose_image()
                    pose_sprite = pyglet.sprite.Sprite(
                        self._pose_image,
                        blend_dest=gl.GL_ONE_MINUS_SRC_COLOR,
                    )
                    pose_sprite.scale_x = self.width / self._pose_image.width
                    pose_sprite.scale_y = self.height / self._pose_image.height
                    pose_sprite.opacity = int(255 * (time_passed - 8) / 2)
                    pose_sprite.draw()
                    pose_sprite.delete()
                elif time_passed < 2:
                    pose_sprite = pyglet.sprite.Sprite(
                        self._frozen_pose_image,
                        blend_dest=gl.GL_ONE_MINUS_SRC_COLOR,
                    )
                    pose_sprite.scale_x = self.width / self._frozen_pose_image.width
                    pose_sprite.scale_y = self.height / self._frozen_pose_image.height
                    pose_sprite.opacity = int(255 * (1 - time_passed / 2))
                    pose_sprite.draw()
                    pose_sprite.delete()

            case FineState.DETECTING_POSES:
                with self._generated_image_lock:
                    self._generated_image.blit(
                        0, 0, width=self.width, height=self.height
                    )

                self._pose_image = self.get_pose_image()

                gl.glEnable(gl.GL_BLEND)
                gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE_MINUS_SRC_COLOR)
                self._pose_image.blit(0, 0, width=self.width, height=self.height)
                gl.glDisable(gl.GL_BLEND)

                if not self._pose_detector.get_full_pose_detected():
                    self.set_state(FineState.DETECTING_POSES)
                else:
                    if time_passed > 8:
                        self.invoke_generation()
                    elif time_passed > 5:
                        progress = (time_passed - 5) / 3
                        self._countdown_arc.angle = -math.tau * (1 - progress)
                        self._countdown_arc.opacity = int(127 * progress)
                        self._countdown_batch.draw()

            case FineState.GENERATING_IMAGE:
                self._frozen_pose_image.blit(0, 0, width=self.width, height=self.height)

                self._wait_batch.draw()
                for index, circle in enumerate(self._wait_circles):
                    circle.opacity = int(
                        127
                        * (1 + math.sin(time.time() * math.pi - math.pi * index / 4))
                        / 2
                    )

                if time_passed <= 1:
                    self._flash_rect.opacity = int(255 * (1 - time_passed))
                    self._flash_batch.draw()

                if time_passed > 60:
                    self.set_state(FineState.DETECTING_POSES)

    def on_key_press(self, symbol: pyglet.window.key, modifiers: pyglet.window.key) -> None:
        """
        Event handler for the key press event.

        Args:
            symbol (pyglet.window.key): The key symbol.
            modifiers (pyglet.window.key): The key modifiers.
        """
        super().on_key_press(symbol, modifiers)

        if symbol == pyglet.window.key.SPACE:
            self.invoke_generation()

    def get_pose_image(self) -> pyglet.image.ImageData:
        """
        Returns the pose image as an ImageData object.

        Returns:
            pyglet.image.ImageData: The pose image.
        """
        return pyglet.image.ImageData(
            self._pose_detector.frame_width,
            self._pose_detector.frame_height,
            "RGB",
            self._pose_detector.get_flipped_pose_image_bytes(),
        )

    def invoke_generation(self) -> None:
        """
        Invokes the image generation process.
        """
        self._server.invoke_generation(
            "starscream.local:9090", "resources/workflow.json"
        )

        self._frozen_pose_image = self._pose_image
        self._frozen_pose_png_data = self._pose_detector.get_pose_image_png()
        self._frozen_canny_png_data = self._pose_detector.get_canny_image_png()

        self.set_state(FineState.GENERATING_IMAGE)

    def get_frozen_pose_image_png(self) -> bytes:
        """
        Returns the frozen pose image data in PNG format.

        Returns:
            bytes: The frozen pose image data.
        """
        return self._frozen_pose_png_data

    def get_frozen_canny_image_png(self) -> bytes:
        """
        Returns the frozen canny image data in PNG format.

        Returns:
            bytes: The frozen canny image data.
        """
        return self._frozen_canny_png_data

    def set_invoked_image(self, data: bytes) -> None:
        """
        Sets the generated image using the provided data.

        Args:
            data (bytes): The image data.
        """
        image = self._pose_detector.make_image(data)

        (height, width) = image.shape[:2]
        with self._generated_image_lock:
            self._generated_image = pyglet.image.ImageData(
                width, height, "RGB", bytes(image)
            )

        self.set_state(FineState.SHOWING_RESULT)


if __name__ == "__main__":
    window = ThisIsFineWindow()
    try:
        pyglet.app.run()
    except (KeyboardInterrupt, Exception) as e:
        import traceback

        traceback.print_exception(e)
    window.cleanup()
